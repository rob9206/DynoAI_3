#!/usr/bin/env python3
"""
DynoAI PyQt6 GUI - PyInstaller Build Script
Creates a standalone Windows executable (.exe)

Usage:
    python scripts/build_exe.py [--onefile] [--debug]

Options:
    --onefile   Create a single-file executable (larger, slower startup)
    --debug     Include debug console window
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path

# Project configuration
PROJECT_NAME = "DynoAI"
PROJECT_VERSION = "1.0.0"
MAIN_SCRIPT = "gui/main.py"
ICON_PATH = "gui/assets/icon.ico"


def get_project_root() -> Path:
    """Get the project root directory."""
    return Path(__file__).parent.parent


def check_dependencies() -> bool:
    """Check if required dependencies are installed."""
    try:
        import PyInstaller

        print(f"âœ“ PyInstaller {PyInstaller.__version__} found")
        return True
    except ImportError:
        print("âœ— PyInstaller not found. Install with: pip install pyinstaller")
        return False


def create_spec_file(
    project_root: Path, onefile: bool = True, debug: bool = False
) -> Path:
    """Create a PyInstaller .spec file."""

    spec_content = f"""# -*- mode: python ; coding: utf-8 -*-
# DynoAI PyQt6 GUI - PyInstaller Spec File
# Auto-generated by build_exe.py

import sys
from pathlib import Path

block_cipher = None

# Add project root to path
project_root = Path(r"{project_root}")

a = Analysis(
    [str(project_root / "{MAIN_SCRIPT}")],
    pathex=[str(project_root)],
    binaries=[],
    datas=[
        # Include assets
        (str(project_root / "gui" / "assets"), "gui/assets"),
        # Include config files
        (str(project_root / "config"), "config"),
    ],
    hiddenimports=[
        # PyQt6 plugins
        "PyQt6.QtCore",
        "PyQt6.QtGui",
        "PyQt6.QtWidgets",
        # API client dependencies
        "requests",
        "json",
        # Data processing
        "numpy",
        # Optional visualization
        "pyqtgraph",
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[
        # Exclude unused Qt modules to reduce size
        "PyQt6.QtWebEngine",
        "PyQt6.QtWebEngineCore",
        "PyQt6.QtWebEngineWidgets",
        "PyQt6.QtMultimedia",
        "PyQt6.QtMultimediaWidgets",
        "PyQt6.QtBluetooth",
        "PyQt6.QtNfc",
        "PyQt6.QtPositioning",
        "PyQt6.QtLocation",
        "PyQt6.QtSensors",
        "PyQt6.QtSerialPort",
        "PyQt6.QtTest",
        "PyQt6.QtSql",
        "PyQt6.QtXml",
        "PyQt6.QtDesigner",
        "PyQt6.QtHelp",
        # Testing
        "pytest",
        "pytest_qt",
        # Development
        "IPython",
        "jupyter",
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

"""

    if onefile:
        spec_content += f"""
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name="{PROJECT_NAME}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console={debug},
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=str(project_root / "{ICON_PATH}") if (project_root / "{ICON_PATH}").exists() else None,
    version="{PROJECT_VERSION}",
)
"""
    else:
        spec_content += f"""
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name="{PROJECT_NAME}",
    debug={debug},
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console={debug},
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=str(project_root / "{ICON_PATH}") if (project_root / "{ICON_PATH}").exists() else None,
    version="{PROJECT_VERSION}",
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name="{PROJECT_NAME}",
)
"""

    spec_path = project_root / "DynoAI.spec"
    spec_path.write_text(spec_content)
    print(f"âœ“ Created spec file: {spec_path}")
    return spec_path


def create_icon_placeholder(project_root: Path) -> None:
    """Create a placeholder icon if one doesn't exist."""
    icon_path = project_root / ICON_PATH
    icon_dir = icon_path.parent

    if not icon_dir.exists():
        icon_dir.mkdir(parents=True)
        print(f"âœ“ Created assets directory: {icon_dir}")

    if not icon_path.exists():
        # Note: In a real scenario, you'd include an actual .ico file
        # This is just a placeholder notice
        print(f"âš  No icon found at {ICON_PATH}")
        print("  Place a .ico file there for a custom application icon")


def build_executable(project_root: Path, spec_path: Path, clean: bool = True) -> bool:
    """Run PyInstaller to build the executable."""

    # Clean previous builds
    if clean:
        dist_dir = project_root / "dist"
        build_dir = project_root / "build"

        if dist_dir.exists():
            shutil.rmtree(dist_dir)
            print(f"âœ“ Cleaned dist directory")

        if build_dir.exists():
            shutil.rmtree(build_dir)
            print(f"âœ“ Cleaned build directory")

    # Run PyInstaller
    print("\nðŸ”¨ Building executable...")
    print("-" * 50)

    cmd = [
        sys.executable,
        "-m",
        "PyInstaller",
        "--clean",
        "--noconfirm",
        str(spec_path),
    ]

    result = subprocess.run(
        cmd,
        cwd=str(project_root),
        capture_output=False,
    )

    return result.returncode == 0


def main():
    """Main build function."""
    parser = argparse.ArgumentParser(
        description="Build DynoAI PyQt6 GUI as standalone executable"
    )
    parser.add_argument(
        "--onefile",
        action="store_true",
        default=True,
        help="Create single-file executable (default: True)",
    )
    parser.add_argument(
        "--onedir", action="store_true", help="Create directory-based distribution"
    )
    parser.add_argument(
        "--debug", action="store_true", help="Include debug console window"
    )
    parser.add_argument(
        "--no-clean", action="store_true", help="Don't clean previous builds"
    )

    args = parser.parse_args()

    # Use onedir if specified, otherwise onefile
    onefile = not args.onedir

    print("=" * 50)
    print(f"DynoAI Build Script v{PROJECT_VERSION}")
    print("=" * 50)
    print()

    # Get project root
    project_root = get_project_root()
    print(f"Project root: {project_root}")
    print()

    # Check dependencies
    if not check_dependencies():
        print("\nâœ— Build failed: missing dependencies")
        return 1

    # Create placeholder icon if needed
    create_icon_placeholder(project_root)

    # Create spec file
    spec_path = create_spec_file(project_root, onefile=onefile, debug=args.debug)

    # Build
    success = build_executable(project_root, spec_path, clean=not args.no_clean)

    print()
    print("-" * 50)

    if success:
        if onefile:
            exe_path = project_root / "dist" / f"{PROJECT_NAME}.exe"
        else:
            exe_path = project_root / "dist" / PROJECT_NAME / f"{PROJECT_NAME}.exe"

        print(f"âœ“ Build successful!")
        print(f"  Executable: {exe_path}")

        if exe_path.exists():
            size_mb = exe_path.stat().st_size / (1024 * 1024)
            print(f"  Size: {size_mb:.1f} MB")

        return 0
    else:
        print("âœ— Build failed!")
        return 1


if __name__ == "__main__":
    sys.exit(main())
