# User Coding Requirements

## Project Description
This is a coding project generated from user requirements via chat interface.

## User Requirements

Project: DynoAI_3 - Deterministic Dyno Tuning Platform

Core Principles:
- Deterministic math (same inputs = same outputs, bit-for-bit)
- Automation-first design (headless CLI, batch processing)
- Production safety (conservative defaults, dry-run mode)
- Formal contracts (explicit schemas, units, invariants)
- World-class reliability

Technology Stack:
- Backend: Python 3.10+, Flask, pandas, numpy, scipy
- Frontend: React 18, TypeScript, Vite
- Database: SQLite (development), PostgreSQL (production)
- Testing: pytest, pytest-asyncio

Coding Standards:
- Type hints for all functions and methods
- Comprehensive docstrings (Google style)
- Unit tests with 80%+ coverage
- Deterministic behavior (no randomness in core logic)
- Conservative error handling
- SHA-256 verification for critical operations

Project Structure:
- api/ - Flask REST API endpoints
- dynoai/core/ - Core analysis algorithms
- dynoai/clients/ - External integrations
- frontend/src/ - React/TypeScript UI
- scripts/ - CLI tools
- tests/ - Test suite
- docs/ - Documentation

Key Modules:
- ve_math.py - VE correction calculations
- ve_operations.py - Apply/rollback system
- cylinder_balancing.py - Per-cylinder analysis
- decel_management.py - Deceleration fuel management
- knock_optimization.py - Knock detection and spark control


Feature Request:

Create comprehensive test suite for DynoAI_3 module: dynoai/core/ve_math.py

Requirements:
- Unit tests for all public functions/classes
- Edge case testing
- Property-based tests where applicable
- Mock external dependencies
- Test deterministic behavior
- 90%+ code coverage
- Use pytest and pytest-asyncio
- Follow DynoAI_3 test conventions

Output location: tests/test_ve_math.py


Requirements:
1. Follow DynoAI_3 coding standards (type hints, docstrings)
2. Maintain deterministic behavior where applicable
3. Include comprehensive unit tests
4. Add inline documentation
5. Consider production safety
6. Integrate with existing DynoAI_3 architecture
7. Export functions/classes for easy import

Please generate production-ready code that can be directly integrated into DynoAI_3.


## Generated Implementation Plan
The following implementation plan was generated by the AI chat planning agent:

```yaml
project_plan:
  title: "DynoAI_3 - ve_math Test Suite"
  description: "Comprehensive, deterministic, production-ready test suite for dynoai/core/ve_math.py using pytest, pytest-asyncio and Hypothesis. Focused on deterministic math, conservative defaults, SHA-256 verification of critical outputs, and 90%+ coverage."
  project_type: "academic"

  file_structure: |
    project_root/
    ├── dynoai/
    │   ├── core/
    │   │   ├── ve_math.py           # Core module under test (must export public API and __all__)
    │   │   └── __init__.py
    ├── tests/
    │   ├── test_ve_math.py         # Comprehensive test suite (requested output location)
    │   └── conftest.py             # Fixtures, deterministic environment setup, mocks
    ├── requirements.txt            # Minimal pinned dependencies for tests & runtime
    ├── pyproject.toml              # Test/packaging configuration (pytest config, black, mypy)
    ├── .coveragerc                 # Coverage config to target ve_math
    ├── scripts/
    │   └── ci_test.sh              # CI wrapper to run tests + coverage + checks
    └── README.md                   # How to run tests & CI notes

  implementation_steps:
    1. "Initial discovery: Inspect dynoai/core/ve_math.py to enumerate public functions and classes. Confirm names, signatures, expected units and invariants. If missing, add explicit exports (__all__) and ensure type hints and Google-style docstrings exist for every public symbol."
    2. "Define deterministic test fixtures in tests/conftest.py:
         - set up fixed numpy print/behaviour if needed (numpy random not used in core).
         - monkeypatch external integrations (I/O, file system, network) referenced by ve_math to prevent flakiness.
         - provide canonical sample inputs/outputs as fixtures (dicts/np.arrays with explicit dtypes)."
    3. "Create tests/test_ve_math.py:
         - For each public function/class, write unit tests that validate:
            * correct results for representative inputs (happy path)
            * edge cases (zeros, infinities, NaNs, extreme but valid physical ranges)
            * type and unit invariants (e.g., input shape, dtype, and unit expectations)
            * deterministic bit-for-bit behaviour where applicable
         - Use pytest.mark.parametrize for combinatorial inputs and boundary values.
         - Use numpy.testing utilities for array equality and type checks; use bitwise comparisons for exact determinism (view float arrays as integer bit patterns when exact match required).
         - For any function that returns floats, adopt stable tolerance strategy: prefer exact bit-level comparisons for well-defined transforms; otherwise use np.testing.assert_allclose with absolute/relative tolerances explicitly documented.
         - Include negative tests asserting conservative error handling (ValueError/TypeError) for invalid inputs.
         - Implement property-based tests with Hypothesis for algebraic properties (e.g., linear scaling invariants, monotonicity) and edge distributions. Use deterministic seeds/settings for reproducibility (Hypothesis settings with max_examples set, fixed seed in CI if required).
         - Implement SHA-256 verification test(s) that compute the SHA-256 digest of canonical output(s) for critical operations and compare to stored canonical hash constants in the test. Document the process to update the canonical hash intentionally (requires change-control comment).
         - Mock out any dependency calls (scipy solvers, external calibration files) to keep tests headless and deterministic. Use monkeypatch or pytest-mock fixtures. Avoid non-deterministic solvers; if solver used, pin tolerances and max-iterations in tests."
    4. "Coverage & CI integration:
         - Add coverage assertion to fail builds if coverage < 90% for dynoai.core.ve_math.
         - Add scripts/ci_test.sh to run lint, tests, and coverage collection:
           * ruff/black (optional) -> mypy (optional) -> pytest with coverage.
         - Configure pyproject.toml and .coveragerc to report only dynoai/core/ve_math.py coverage and to include tests in CI reporting."
    5. "Documentation & maintenance:
         - Add inline documentation in tests describing rationale for each property test and SHA-256 expected hashes.
         - Add README.md instructions with commands for running tests locally, updating canonical hashes, and when to relax deterministic checks.
         - Add developer note to ve_math.py: exporting __all__, deterministic numeric types (np.float64), and explicit unit contracts in docstrings."
    6. "Validation & finalization:
         - Run the full suite in a clean environment (CI script) and confirm:
            * All tests pass on Python 3.10+.
            * Coverage >= 90% for dynoai/core/ve_math.py.
            * No external network or file system access during tests.
         - If tests expose missing type hints or docstrings in ve_math, add/update them and re-run tests."

  dependencies:
    required_packages:
      - "python>=3.10"
      - "Flask>=2.0"
      - "pandas>=1.4"
      - "numpy>=1.23"
      - "scipy>=1.9"
      - "pytest>=7.0"
      - "pytest-asyncio>=0.20"
      - "hypothesis>=6.0"
      - "pytest-cov>=4.0"
      - "coverage>=6.0"
    optional_packages:
      - "pytest-mock: mocking convenience (monkeypatch alternative)"
      - "mypy: static typing checks"
      - "black/ruff: formatting/linting"
      - "pre-commit: enforce formatting and tests on commit"
    setup_commands:
      - "python -m venv .venv"
      - "source .venv/bin/activate  # or .venv\\Scripts\\activate on Windows"
      - "pip install -r requirements.txt"
      - "pip install -e .  # optional if package is installed locally"
      - "pytest --cov=dynoai.core.ve_math --cov-report=xml --cov-fail-under=90 -q"

  tech_stack:
    language: "Python (primary), TypeScript (frontend exists but not part of these tests)"
    frameworks: ["Flask (backend)", "React (frontend - not covered here)"]
    key_libraries: ["numpy", "pandas", "scipy", "pytest", "hypothesis"]

  main_features:
    - "Complete unit tests for every public function and class in dynoai/core/ve_math.py"
    - "Edge-case coverage for zeros, infinities, NaNs, dtype/shape mismatches and extremes"
    - "Property-based tests (Hypothesis) for algebraic and scaling invariants"
    - "Deterministic checks: bitwise equality for exact transforms and explicit tolerances otherwise"
    - "SHA-256 verification tests for critical canonical outputs to detect unintended changes"
    - "Mocks for external dependencies to keep tests headless and CI-friendly"
    - "CI/coverage integration with fail-fast on coverage < 90%"

Notes and implementation guidance (inline):
  - "Ensure ve_math.py explicitly exports a stable public API: add __all__ = ['compute_ve_correction', 'VECorrection', ...]. This makes import and testing straightforward."
  - "All functions must have type hints and Google-style docstrings describing units (e.g., RPM -> rev/min, AFR -> dimensionless), input shapes and invariants. Tests rely on these contracts."
  - "Prefer numpy dtypes for deterministic bitwise checks: use np.array([...], dtype=np.float64) for canonical test vectors. Where exact equality is expected, compare bit patterns via .view(np.int64) or np.testing.assert_array_equal on integer views."
  - "Hypothesis: keep max_examples low for CI (e.g., 200) and seed tests for reproducibility. Example: from hypothesis import settings; settings(max_examples=200, derandomize=True)."
  - "SHA-256 verification pattern:
       * Create canonical_inputs fixture -> call function -> get canonical_output (bytes or deterministic binary representation)
       * Compute digest = hashlib.sha256(canonical_output_bytes).hexdigest()
       * Compare digest to expected constant stored in test file (document how to regenerate via a script/CI step with sign-off).
     This verifies that critical outputs remain unchanged across refactors if intended."
  - "Mock external solver calls (scipy.optimize) if they are non-deterministic; instead test the algorithmic wrapper by injecting a deterministic solver function via dependency injection or monkeypatch."
  - "For async functions (if any), use pytest.mark.asyncio and pytest-asyncio fixtures; though ve_math is expected to be synchronous."
  - "Conservative error handling tests: assert that invalid inputs raise exceptions with clear messages (avoid swallowing exceptions)."
  - "Maintain test file readability: group tests by function/class and prefix tests with purpose comments and invariants being validated."

Example test structure within tests/test_ve_math.py (high-level outline to implement):
  - "Imports: typing, numpy as np, pytest, hypothesis strategies, hashlib, import ve_math public API"
  - "Helper utilities: canonical_vector(dtype=np.float64), bits_equal(a,b)"
  - "Fixtures: canonical_inputs, canonical_outputs, patched_external"
  - "Unit tests: test_compute_ve_correction_nominal, test_compute_ve_correction_zero_rpm, test_compute_ve_correction_negative_input_raises"
  - "Array/dtype tests: test_returns_float64_and_shape"
  - "Property tests: test_linear_scaling_invariant (Hypothesis)"
  - "Determinism tests: test_bitwise_determinism_for_repeated_calls"
  - "SHA-256 test: test_canonical_output_hash_matches_expected"
  - "Mock tests: test_calls_solver_with_expected_args (monkeypatch/scoped mock)"

Risk mitigation & acceptance criteria:
  - "Acceptance requires: tests pass on clean environment, coverage >= 90% for ve_math, no network or external file dependencies, deterministic outputs across repeated runs."
  - "If flakiness appears, isolate the flake by seeding or mocking nondeterministic helpers; never modify core algorithm to use randomness for testing convenience."
  - "Document any intentional changes to canonical SHA-256 hashes via commit message and CHANGELOG entry."

This plan is focused on being directly actionable: use the file tree to add the two test files (tests/test_ve_math.py and tests/conftest.py), adapt ve_math.py to export its public API if necessary, and follow the implementation steps to achieve deterministic, high-coverage, production-safe tests that integrate into DynoAI_3 CI.
```

## Project Metadata
- **Input Type**: Chat Input
- **Generation Method**: AI Chat Planning Agent
- **Timestamp**: 1765806514
